<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>ERROR PAGE</title>
    <style type="text/css">
        html,
        body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .container {
            width: 100 ï¼…;
            height: 100%;
            margin-top: 5%;
            padding: 0;
            background-color: #ffffff;
        }
    </style>

    <style>
        /* latin-ext */
        @font-face {
            font-family: "Varela";
            font-style: normal;
            font-weight: 30;
            src: local("Varela"), url(https://fonts.gstatic.com/s/varela/v9/DPEtYwqExx0AWHX5DR4ETvw.woff2) format("woff2");
            unicode-range: U+0100-024F, U+0259, U+1E00-1EFF, U+2020, U+20A0-20AB, U+20AD-20CF, U+2113, U+2C60-2C7F, U+A720-A7FF;
        }

        /* latin */
        @font-face {
            font-family: "Varela";
            font-style: normal;
            font-weight: 30;
            src: local("Varela"), url(https://fonts.gstatic.com/s/varela/v9/DPEtYwqExx0AWHX5Ax4E.woff2) format("woff2");
            unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
        }

        body {
            background: #ffffff;
            font-family: "Varela", sans-serif;
        }

        .glitch {
            font-size: 20px;
            position: relative;
            font-weight: bold;
        }

        @keyframes noise-anim {
            0% {
                clip: rect(73px, 9999px, 15px, 0);
            }

            5% {
                clip: rect(3px, 9999px, 100px, 0);
            }

            10% {
                clip: rect(93px, 9999px, 80px, 0);
            }

            15% {
                clip: rect(99px, 9999px, 19px, 0);
            }

            20% {
                clip: rect(41px, 9999px, 34px, 0);
            }

            25% {
                clip: rect(82px, 9999px, 54px, 0);
            }

            30% {
                clip: rect(8px, 9999px, 62px, 0);
            }

            35% {
                clip: rect(19px, 9999px, 26px, 0);
            }

            40% {
                clip: rect(82px, 9999px, 50px, 0);
            }

            45% {
                clip: rect(97px, 9999px, 40px, 0);
            }

            50% {
                clip: rect(31px, 9999px, 47px, 0);
            }

            55% {
                clip: rect(34px, 9999px, 34px, 0);
            }

            60% {
                clip: rect(33px, 9999px, 74px, 0);
            }

            65% {
                clip: rect(27px, 9999px, 92px, 0);
            }

            70% {
                clip: rect(59px, 9999px, 100px, 0);
            }

            75% {
                clip: rect(8px, 9999px, 93px, 0);
            }

            80% {
                clip: rect(93px, 9999px, 73px, 0);
            }

            85% {
                clip: rect(100px, 9999px, 13px, 0);
            }

            90% {
                clip: rect(20px, 9999px, 24px, 0);
            }

            95% {
                clip: rect(51px, 9999px, 100px, 0);
            }

            100% {
                clip: rect(57px, 9999px, 7px, 0);
            }
        }

        .glitch:after {
            content: attr(data-text);
            position: absolute;
            left: 50%;
            transform: translateX(-51%);
            text-shadow: -1px 0 red;
            top: 0;
            color: rgb(49, 234, 255);
            background: rgba(75, 47, 157, 0.65);
            overflow: hidden;
            clip: rect(0, 900px, 0, 0);
            animation: noise-anim 1s infinite linear alternate-reverse;
        }

        @keyframes noise-anim-2 {
            0% {
                clip: rect(99px, 9999px, 98px, 0);
            }

            5% {
                clip: rect(87px, 9999px, 41px, 0);
            }

            10% {
                clip: rect(33px, 9999px, 40px, 0);
            }

            15% {
                clip: rect(33px, 9999px, 43px, 0);
            }

            20% {
                clip: rect(89px, 9999px, 22px, 0);
            }

            25% {
                clip: rect(12px, 9999px, 73px, 0);
            }

            30% {
                clip: rect(47px, 9999px, 18px, 0);
            }

            35% {
                clip: rect(62px, 9999px, 98px, 0);
            }

            40% {
                clip: rect(30px, 9999px, 94px, 0);
            }

            45% {
                clip: rect(69px, 9999px, 65px, 0);
            }

            50% {
                clip: rect(87px, 9999px, 47px, 0);
            }

            55% {
                clip: rect(12px, 9999px, 3px, 0);
            }

            60% {
                clip: rect(63px, 9999px, 14px, 0);
            }

            65% {
                clip: rect(88px, 9999px, 97px, 0);
            }

            70% {
                clip: rect(15px, 9999px, 23px, 0);
            }

            75% {
                clip: rect(88px, 9999px, 20px, 0);
            }

            80% {
                clip: rect(68px, 9999px, 54px, 0);
            }

            85% {
                clip: rect(58px, 9999px, 66px, 0);
            }

            90% {
                clip: rect(98px, 9999px, 97px, 0);
            }

            95% {
                clip: rect(86px, 9999px, 16px, 0);
            }

            100% {
                clip: rect(79px, 9999px, 77px, 0);
            }
        }

        .glitch:before {
            content: attr(data-text);
            position: absolute;
            left: 50%;
            transform: translateX(-49%);
            text-shadow: 1px 0 rgba(252, 252, 251, 0.81);
            top: 0;
            color: rgb(147, 105, 252);
            background: #B9AEE5FF;
            overflow: hidden;
            clip: rect(0, 900px, 0, 0);
            animation: noise-anim-2 1s infinite linear alternate-reverse;
        }
    </style>

</head>

<body>
<div style="left:50%;top: 20%;text-align: center;position: absolute;transform: translate(-50%,-50%);z-index: 999">
    <h1>
        UNABLE TO FORWARD REQUEST TO YOUR SERVER
    </h1>
    <p style="font-size: 20px">
        please check your config or make sure your serve is started!
    </p>
    <hr/>
    <div style="display: flex; justify-content:center; align-items: center;">
        <div style="font-size: 15px;font-weight: 100;display: inline-block;margin-right: 5px">power by</div>
        <div class="glitch" data-text="FNU1.0.0" style="display: inline-block">
            <a href="https://github.com/Freedy001/FNU" style="color: rgb(0,0,0);text-decoration:none">FNU1.0.0</a>
        </div>
    </div>
</div>

<div id="container" style="transform: rotateZ(15deg)" class="container"></div>
<script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
<script type="text/javascript">
    var RENDERER = {
        PARTICLE_COUNT: 1500,
        PARTICLE_RADIUS: 1,
        MAX_ROTATION_ANGLE: Math.PI / 60,
        TRANSLATION_COUNT: 500,

        init: function (strategy) {
            this.setParameters(strategy);
            this.createParticles();
            this.setupFigure();
            this.reconstructMethod();
            this.bindEvent();
            this.drawFigure();
        },
        setParameters: function (strategy) {
            this.$window = $(window);

            this.$container = $('#container');
            this.width = this.$container.width();
            this.height = this.$container.height();

            this.$canvas = $('<canvas />').attr({
                width: this.width,
                height: this.height
            }).appendTo(this.$container);
            this.context = this.$canvas.get(0).getContext('2d');

            this.center = {
                x: this.width / 2,
                y: this.height / 2
            };

            this.rotationX = this.MAX_ROTATION_ANGLE;
            this.rotationY = this.MAX_ROTATION_ANGLE;
            this.strategyIndex = 0;
            this.translationCount = 0;
            this.theta = 0;

            this.strategies = strategy.getStrategies();
            this.particles = [];
        },
        createParticles: function () {
            for (var i = 0; i < this.PARTICLE_COUNT; i++) {
                this.particles.push(new PARTICLE(this.center));
            }
        },
        reconstructMethod: function () {
            this.setupFigure = this.setupFigure.bind(this);
            this.drawFigure = this.drawFigure.bind(this);
            this.changeAngle = this.changeAngle.bind(this);
        },
        bindEvent: function () {
            this.$container.on('click', this.setupFigure);
            // this.$container.on('mousemove', this.changeAngle);
            this.rotationX = 0.01;
            this.rotationY = 0.03;
            setInterval(() => {
                RENDERER.rotationY = Math.random() * 0.03;
                RENDERER.rotationX = Math.random() * 0.01;
            }, 10000)
        },
        changeAngle: function (event) {
            var offset = this.$container.offset(),
                x = event.clientX - offset.left + this.$window.scrollLeft(),
                y = event.clientY - offset.top + this.$window.scrollTop();

            this.rotationX = (this.center.y - y) / this.center.y * this.MAX_ROTATION_ANGLE;
            this.rotationY = (this.center.x - x) / this.center.x * this.MAX_ROTATION_ANGLE;
            // console.log(this.rotationX,this.rotationY)
        },
        setupFigure: function () {
            for (var i = 0, length = this.particles.length; i < length; i++) {
                this.particles[i].setAxis(this.strategies[this.strategyIndex]());
            }
            if (++this.strategyIndex == this.strategies.length) {
                this.strategyIndex = 0;
            }
            this.translationCount = 0;
        },
        drawFigure: function () {
            requestAnimationFrame(this.drawFigure);

            this.context.fillStyle = 'rgb(255,255,255)';
            this.context.fillRect(0, 0, this.width, this.height);

            for (var i = 0, length = this.particles.length; i < length; i++) {
                var axis = this.particles[i].getAxis2D(this.theta);

                this.context.beginPath();
                this.context.fillStyle = axis.color;
                this.context.arc(axis.x, axis.y, this.PARTICLE_RADIUS, 0, Math.PI * 2, false);
                this.context.fill();
            }
            this.theta++;
            this.theta %= 360;

            for (var i = 0, length = this.particles.length; i < length; i++) {
                this.particles[i].rotateX(this.rotationX);
                this.particles[i].rotateY(this.rotationY);
            }
            this.translationCount++;
            this.translationCount %= this.TRANSLATION_COUNT;

            if (this.translationCount == 0) {
                this.setupFigure();
            }
        }
    };
    var STRATEGY = {
        SCATTER_RADIUS: 150,
        CONE_ASPECT_RATIO: 1.5,
        RING_COUNT: 5,

        getStrategies: function () {
            var strategies = [];

            for (var i in this) {
                if (this[i] == arguments.callee || typeof this[i] != 'function') {
                    continue;
                }
                strategies.push(this[i].bind(this));
            }
            return strategies;
        },
        createSphere: function () {
            var cosTheta = Math.random() * 2 - 1,
                sinTheta = Math.sqrt(1 - cosTheta * cosTheta),
                phi = Math.random() * 2 * Math.PI;

            return {
                x: this.SCATTER_RADIUS * sinTheta * Math.cos(phi),
                y: this.SCATTER_RADIUS * sinTheta * Math.sin(phi),
                z: this.SCATTER_RADIUS * cosTheta,
                hue: Math.round(phi / Math.PI * 30)
            };
        },
        createTorus: function () {
            var theta = Math.random() * Math.PI * 2,
                x = this.SCATTER_RADIUS + this.SCATTER_RADIUS / 6 * Math.cos(theta),
                y = this.SCATTER_RADIUS / 6 * Math.sin(theta),
                phi = Math.random() * Math.PI * 2;

            return {
                x: x * Math.cos(phi),
                y: y,
                z: x * Math.sin(phi),
                hue: Math.round(phi / Math.PI * 30)
            };
        },
        createCone: function () {
            var status = Math.random() > 1 / 3,
                x,
                y,
                phi = Math.random() * Math.PI * 2,
                rate = Math.tan(30 / 180 * Math.PI) / this.CONE_ASPECT_RATIO;

            if (status) {
                y = this.SCATTER_RADIUS * (1 - Math.random() * 2);
                x = (this.SCATTER_RADIUS - y) * rate;
            } else {
                y = -this.SCATTER_RADIUS;
                x = this.SCATTER_RADIUS * 2 * rate * Math.random();
            }
            return {
                x: x * Math.cos(phi),
                y: y,
                z: x * Math.sin(phi),
                hue: Math.round(phi / Math.PI * 30)
            };
        },
        createVase: function () {
            var theta = Math.random() * Math.PI,
                x = Math.abs(this.SCATTER_RADIUS * Math.cos(theta) / 2) + this.SCATTER_RADIUS / 8,
                y = this.SCATTER_RADIUS * Math.cos(theta) * 1.2,
                phi = Math.random() * Math.PI * 2;

            return {
                x: x * Math.cos(phi),
                y: y,
                z: x * Math.sin(phi),
                hue: Math.round(phi / Math.PI * 30)
            };
        }
    };
    var PARTICLE = function (center) {
        this.center = center;
        this.init();
    };
    PARTICLE.prototype = {
        SPRING: 0.01,
        FRICTION: 0.9,
        FOCUS_POSITION: 300,
        COLOR: 'hsl(%hue, 80%, 0%)',

        init: function () {
            this.x = 0;
            this.y = 0;
            this.z = 0;
            this.vx = 0;
            this.vy = 0;
            this.vz = 0;
            this.color;
        },
        setAxis: function (axis) {
            this.translating = true;
            this.nextX = axis.x;
            this.nextY = axis.y;
            this.nextZ = axis.z;
            this.hue = axis.hue;
        },
        rotateX: function (angle) {
            var sin = Math.sin(angle),
                cos = Math.cos(angle),
                nextY = this.nextY * cos - this.nextZ * sin,
                nextZ = this.nextZ * cos + this.nextY * sin,
                y = this.y * cos - this.z * sin,
                z = this.z * cos + this.y * sin;

            this.nextY = nextY;
            this.nextZ = nextZ;
            this.y = y;
            this.z = z;
        },
        rotateY: function (angle) {
            var sin = Math.sin(angle),
                cos = Math.cos(angle),
                nextX = this.nextX * cos - this.nextZ * sin,
                nextZ = this.nextZ * cos + this.nextX * sin,
                x = this.x * cos - this.z * sin,
                z = this.z * cos + this.x * sin;

            this.nextX = nextX;
            this.nextZ = nextZ;
            this.x = x;
            this.z = z;
        },
        rotateZ: function (angle) {
            var sin = Math.sin(angle),
                cos = Math.cos(angle),
                nextX = this.nextX * cos - this.nextY * sin,
                nextY = this.nextY * cos + this.nextX * sin,
                x = this.x * cos - this.y * sin,
                y = this.y * cos + this.x * sin;

            this.nextX = nextX;
            this.nextY = nextY;
            this.x = x;
            this.y = y;
        },
        getAxis3D: function () {
            this.vx += (this.nextX - this.x) * this.SPRING;
            this.vy += (this.nextY - this.y) * this.SPRING;
            this.vz += (this.nextZ - this.z) * this.SPRING;

            this.vx *= this.FRICTION;
            this.vy *= this.FRICTION;
            this.vz *= this.FRICTION;

            this.x += this.vx;
            this.y += this.vy;
            this.z += this.vz;

            return {
                x: this.x,
                y: this.y,
                z: this.z
            };
        },
        getAxis2D: function (theta) {
            var axis = this.getAxis3D(),
                scale = this.FOCUS_POSITION / (this.FOCUS_POSITION + axis.z);

            return {
                x: this.center.x + axis.x * scale,
                y: this.center.y - axis.y * scale,
                color: this.COLOR.replace('%hue', this.hue + theta)
            };
        }
    };

    $(function () {
        RENDERER.init(STRATEGY);
    });
</script>
</body>

</html>
